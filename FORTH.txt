*80 'INCREDIBLY CURSED WAY OF INLINING EXIT: MAKE THE ADDRESS THE OPCODE!
$EXIT
&H0004 'LENGTH
0 'LINK
>EXIT
]

*&H100

;@13
MOVE <DEND 14

;@QPRINT
$AVC3 FORTH is starting...
10
10
10
0

'LOAD IN ---------FORTH INTO COMMAND BUFFER

PE _0123
MOVE <NAME 0
MOVE <COMMAND 1
LOAD 0 1 2 3

JEI 0 3 <HALT

'SET BUFFTOP
STOREM 2 <BUFFTOP
RE _0123

REFR
JUMP <QUIT

>NAME
$---------FORTH
0

'FORTH FOR AVC3

'SUBROUTINE-THREADED TO TAKE ADVANTAGE OF AVC3'S IMPLIED SUBROUTINE CALLS

'USES AVC3'S S11 AND S12 FOR DATA AND RETURN STACKS.

'SYSTEM VARIABLES----------------------------
>_STATE 0 '0=EXECUTION, NON-0=COMPILATION
>_HERE <DEND 'NEXT FREE BYTE OF MEMORY FOR COMPILATION
>_LATEST <LAT 'LAST DICTIONARY DEFINITION THAT WAS SAVED.
>_SLOW 0 'SLOWMODE FLAG
'BASE AND S0 ARE SUPERFLUOUS. USE S11 AND ;_BASE
>_CLIP 0 'CLIPBOARD COUNTER
>_ISLIT 0 'IS IT A LITERAL?
>_PRINTED 0 'ANYTHING PRINTED SINCE LAST INPUT
>_RAMTOP ;_LOC 'END OF USER MEMORY

'BUFFER VARIABLES
>BUFFTOP <COMMAND
>CURRKEY <COMMAND

'WORD BUFFER COUNTER
>WORD_CURR <SPACE

'BUFFERS-------------------------------------
>COMMAND +&H2000 'COMMAND BUFFER
>SPACE +256 'WORD BUFFER
>LOADNAME +14 'LOAD BUFFER

>DICTIONARY 'USER DICTIONARY STARTS HERE

'DICTIONARY FORMAT

'NAME
'IMMEDIATE FLAG,HIDDEN FLAG,NAME LENGTH
'LINK: POINTER TO PREVIOUS WORD
'CODE

'IMMEDIATE MASK: &H200
'HIDDEN MASK: &H100
'NAME MASK: &HFF
'YES NAMES CAN BE SUPER LONG. WHY NOT?

'POP AND DISCARD A NUMBER
$DROP
&H0004 'LENGTH
<EXIT '(N -- )

'CODE
>DROP
INC 11
]

'SWAP TOP 2 NUMBERS
$SWAP
&H0004 'LENGTH
<DROP '(A B -- B A)

'CODE
>SWAP
SWAP .11 =
]

'COPY TOS
$DUP
&H0003 'LENGTH
<SWAP '(N -- N N)

'CODE
>DUP
COPY ,11 .11
]

'ROTATE
$ROT
&H0003 'LENGTH
<DUP '(A B C -- B C A)

'CODE
>ROT
PR _012 _012
S _12
R 0
EXIT _012

'ANTI-ROTATE
$-ROT
&H0004 'LENGTH
<ROT '(A B C -- C A B)

'CODE
>-ROT
PR _012 _012
R 2
S _01
EXIT _012

'DROP TWICE
$2DROP
&H0005
<-ROT '(N N --)

'CODE
>2DROP
ADDI 2 11 = %
]

'DUP TOP TWO ELEMENTS
$2DUP
&H0004
<2DROP '(A B -- A B A B)

'CODE
>2DUP
PR _01 _01
S _01
SRE _01 _01

'SWAP TOP PAIRS OF ELEMENTS
$2SWAP
&H0005
<2DUP '(A B C D -- C D A B)

>2SWAP
PR _0123 _0123
S _23
SRE _01 _0123

'DUPLICATE TOS IF NONZERO
$?DUP
&H0004
<2SWAP '(N -- N N) IF N IS NOT ZERO, OTHERWISE (N -- N)

>?DUP '?D...
JEI 0 ,11 <-] 'EARLY RETURN
COPY ,11 .11

>-] ] 'COMMON TO ALL EARLY RETURNS

'INCREMENT TOS
$1+
&H0002
<?DUP '(N -- N+1)

>1+
INC .11
]

'DECREMENT TOS
$1-
&H0002
<1+ '(N -- N-1)

>1-
DEC .11
]

'INCREMENT TOS BY 4
$4+
&H0002
<1- '(N -- N+1)

>4+
ADDI 4 .11 = %
]

'DECREMENT TOS BY 4
$4-
&H0002
<4+ '(N -- N-1)

>4-
SUBI 4 .11 = %
]

'ADD
$+
&H0001
<4- '(A B -- A+B)

>+
ADDR .11 = = %
]

'SUB
$-
&H0001
<+ '(A B -- A-B)

>-
SUBR .11 = = %
]

'MUL
$*
&H0001
<- '(A B -- A*B)

>*
MULR .11 = % .11
]

'DIVMOD
$/MOD
&H0004
<* '(A B -- A%B A/B)

>/MOD
DIVR .11 = = =
]

'EQUALITY
$=
&H0001
</MOD '(A B -- A=B?)

>=
JER .11 = <TRUE 'COMPARE

>FALSE 'COMMON FALSE CODE
I 0 'RETURN ZERO
]

>TRUE 'COMMON TRUE CODE
I &HFFFF 'RETURN ALL 1
]

'INEQUALITY
$<>
&H0002
<= '(A B -- A<>B?)

><>
JNR .11 = <TRUE
JUMP <FALSE 'VERY COMPACT CODE NOW FALSE IS DEFINED

'LESS THAN
$<
&H0001
<<> '(A B -- A<B?)

><
JGR- .11 = <TRUE 'SWAPPED DUE TO POP ORDER
JUMP <FALSE

'GREATER THAN
$>
&H0001
<< '(A B -- A>B?)

>>
JLR- .11 = <TRUE 'SWAPPED DUE TO POP ORDER
JUMP <FALSE

'LESS THAN OR EQUAL
$<=
&H0002
<> '(A B -- A<=B?)

><=
JLR- .11 = <FALSE 'FALSE IF GREATER
JUMP <TRUE 'OTHERWISE TRUE

'GREATER THAN OR EQUAL
$>=
&H0002
<<= '(A B -- A>=B?)

>>=
JGR- .11 = <FALSE 'FALSE IF LESS
JUMP <TRUE 'OTHERWISE TRUE

'EQUAL TO ZERO?
$0=
&H0002
<>= '(N -- N=0?)

>0=
JEI 0 .11 <TRUE
JUMP <FALSE

'NOT EQUAL TO ZERO?
$0<>
&H0003
<0= '(N -- N<>0?)

>0<>
JNI 0 .11 <TRUE
JUMP <FALSE

'LESS THAN ZERO
$0<
&H0002
<0<>

>0<
JGI- 0 .11 <TRUE 'IS 0 > TOS?
JUMP <FALSE

'GREATER THAN ZERO
$0>
&H0002
<0<

>0>
JLI- 0 .11 <TRUE 'IS 0 < TOS?
JUMP <FALSE

'LESS THAN OR EQUAL TO ZERO
$0<=
&H0003
<0>

>0<=
JLI- 0 .11 <FALSE 'FALSE IF 0 > TOS
JUMP <TRUE

'GREATER THAN OR EQUAL TO ZERO
$0>=
&H0003
<0<=

>0>=
JGI- 0 .11 <FALSE 'FALSE IF 0 < TOS
JUMP <TRUE

'BITWISE AND
$AND
&H0003
<0>=

>AND
ANDR .11 = =
]

'BITWISE XOR
$XOR
&H0003
<AND

>XOR
XORR .11 = =
]

'BITWISE OR
$OR
&H0002
<XOR

>OR
ORR .11 = =
]

'BITWISE NOT
$INVERT
&H0006
<OR

>INVERT
NOT .11 =
]

'LITERAL
$LIT
&H0003
<INVERT

>LIT
LOADR ,12 .11 'GET LITERAL
INC .12 'ADVANCE RETURN ADDRESS
]

'STORE
$!
&H0001
<LIT

>!
SWAP .11 =
STORER .11 = 'STORE DATA AT ADDRESS
]

'FETCH
$@
&H0001
<!

>@
LOADR .11 = 'LOAD DATA AT ADDRESS
]

'ADD STORE
$+!
&H0002
<@

>+!
PR _01 _01
'R0=THING TO ADD
'R1=ADDRESS
ADDR 0 ,1 = %
EXIT _01

'SUB STORE
$-!
&H0002
<+!

>-!
PR _01 _01
'R0=THING TO SUB
'R1=ADDRESS
SUBR 0 ,1 = %
EXIT _01

'BLOCK MEMORY COPY
$CMOVE
&H0005
<-! '(START END LENGTH --)

>CMOVE
SWAP .11 =
JUMP ;@FCP 'PERFORM COPY

'SYSTEM VARIABLES

'LATEST
$LATEST
&H0006
<CMOVE

>LATEST
I <_LATEST
]

'STATE
$STATE
&H0005
<LATEST

>STATE
I <_STATE
]

'HERE
$HERE
&H0004
<STATE

>HERE
I <_HERE
]

'BASE
$BASE
&H0004
<HERE

>BASE
I ;_BASE
]

'CONSTANTS
'VERSION
$VERSION
&H0007
<BASE

>VERSION
I 1
]

'R0
$R0
&H0002
<VERSION

>R0
I 0
]

'S0
$S0@
&H0003
<R0

>S0
I &HF000
]

'F_IMMED
$F_IMMED
&H0007
<S0

>F_IMMED
I &H200
]

'F_HIDDEN
$F_HIDDEN
&H0008
<F_IMMED

>F_HIDDEN
I &H100
]

'F_LENMASK
$F_LENMASK
&H0009
<F_HIDDEN

>F_LENMASK
I &HFF
]

'RETURN STACK WORDS

'TO R
$>R
&H0002
<F_LENMASK 'PUT INTO PARAMETER STACK

>>R
PUSHR .11 12
SWAP .12 = 'RECOVER RETURN ADDRESS
]

'FROM R
$R>
&H0002
<>R

>R>
SWAP .12 = 'GET RETURN ADDRESS OUT OF THE WAY
R .12
]

'FETCH RSP
$RSP@
&H0004
<R>

>RSP@
R 12
INC .11 'CORRECT FOR RSP@'S STACK FRAME
]

'STORE RSP
$RSP!
&H0004
<RSP@

>RSP!
COPY .12 .11 'FIRST SAVE RETURN ADDRESS
SWAP .11 = 'NOW NEW RSP AT TOS
COPY .11 12 'SET RSP
COPY .11 .12 'PUSH RETURN ADDRESS
]

'R DROP
$RDROP
&H0005
<RSP!

>RDROP
SWAP .12 = 'GET STACK ITEM BURIED UNDER R.A.
INC 12 'DROP
]

'DATA STACK WORDS

'DSP FETCH
$DSP@
&H0004
<RDROP

>DSP@
R 11
]

'DSP STORE
$DSP!
&H0004
<DSP@

>DSP!
G 11
]

'INPUT AND OUTPUT

'_KEY
'GETS NEXT THING IN THE BUFFER, OTHERWISE REFILLS BUFFER BY CALLING INPUT

'PUTS NEXT KEY ON THE PARAMETER STACK

$KEY
&H0003
<DSP!

>KEY
JER <BUFFTOP <CURRKEY <GET_INPUT 'INPUT EXHAUSTED?

>GET_KEY
POP <CURRKEY .11 'GET FROM [CURRKEY]
]

>GET_INPUT

CLIPR <_CLIP .11
JNI 0 .11 <GET_CLIP 'CLIPBOARD EXHAUSTED?

I 8 ;@PC 'DELETE LAST CURSOR

JNI 1 <_PRINTED <GET_NLSKIP
;@NL
>GET_NLSKIP
STOREIM 0 <_PRINTED
<DEPTH
ADDI &HE100 .11 = % 'PRINT DEPTH AS LITTLE BLOCK
;@PC
I &HE17F ;@PC 'PRINT A SPACE
STOREIM <COMMAND <CURRKEY 'RESET CURRKEY
STOREIR 0 <CURRKEY 'RESET BUFFER START

>GET_INPUTR
I <COMMAND 'PUSH COMMAND BUFFER SPACE
I &H2000
;@INPUT
<2DUP
;@MPRINT 'REPRINT INPUT
ADDR .11 = <BUFFTOP % 'COLLAPSE LOC+LEN TO END POINT AND STORE IN BUFFTOP
JER <BUFFTOP <CURRKEY <GET_INPUTR 'USER TYPED NOTHING?

STOREIR 10 <BUFFTOP 'AUTO-INSERT ENTER
INC <BUFFTOP
;@NL
I ! ;@PC
REFR
JUMP <GET_KEY

>GET_CLIP
CLIPR <_CLIP .11
INC <_CLIP
]

>HALT HALT

'OUTPUT BYTE FROM STACK

$EMIT
&H0004
<KEY

>EMIT
STOREIM ! ;_CRPC
;@CURPC
REFR
STOREIM 1 <_PRINTED
]

'"QUIET" EMIT, DOESN'T REFRESH DISPLAY
$QEMIT
&H0005
<EMIT

>QEMIT
;@PC 'DRAW CHARACTER
]

'WORD

'THIS GETS JUST ONE FORTH WORD AND RETURNS ITS LOCATION AND LENGTH

$WORD
&H0004
<QEMIT

>WORD 'W...
PSR 0 'USED TO KEEP KEY RESULT
'FIRST SKIP COMMENTS AND WHITESPACE

>W_START
<KEY
G 0
JEI ! 0 <W_COMMENT 'COMMENT?
<W_WHITECHECK 'CHECK FOR WHITESPACE
JEI -1 .11 <W_START

STOREIM <SPACE <WORD_CURR 'RESET WORDCURR

>W_INWORD 'INSIDE A WORD NOW
STORER 0 <WORD_CURR 'STORE KEY IN WORDCURR
INC <WORD_CURR 'INCREMENT WORD_CURR
<KEY
G 0
<W_WHITECHECK
JEI 0 .11 <W_INWORD

I <SPACE 'LOCATION
SUBI <SPACE <WORD_CURR .11 % 'LENGTH
EXIT _0


>W_COMMENT
<KEY
G 0
JNI 10 0 <W_COMMENT
JUMP <W_START


'COMPARES R0 TO WHITESPACE AND RETURNS TRUE IF FOUND
>W_WHITECHECK
FORKI+ 32 0 <FALSE <TRUE 'ABOVE 32 = FALSE
JUMP <TRUE '32

'NUMBER PARSER

'USES A STRING LOCATION+LENGTH

'FIRST RETURNS NUMBER OF UNCONVERTED CHRS
'THEN RETURNS ACTUAL PARSED NUMBER

$NUMBER
&H0006
<WORD

>NUMBER 'NUM
PR _012345 _01
'R0=LOCATION
'R1=LENGTH
MOVE 0 2 'R2=NEGATIVE FLAG
COPY 0 3 'R3=DIGIT POINTER
MOVE 0 4 'R4=NUMBER CONSTRUCTED SO FAR
ADDR 3 1 5 % 'R5=END POINTER

JEI 0 1 <NUM_END 'NOTHING?

'CHECK FOR LEADING HYPHEN
JNI !- ,3 <NUM_HYSKIP

MOVE 1 2 'SET NEGATIVE FLAG
JEI 1 1 <NUM_END 'JUST A HYPHEN?
INC 3

>NUM_HYSKIP
'LOOP READING DIGITS
MULR ;_BASE 4 = = 'NUM*=BASE
R .3 'GET DIGIT
;@D_I 'CONVERT TO NUMBER
JLR+ .11 ;_BASE <NUM_VALID 'VALID DIGIT FOUND

'INVALID DIGIT
DIVR ;_BASE 4 = = 'NUM/=BASE
DEC 3

>NUM_END
JEI 0 2 <NUM_NEGSKIP

TWO 4 = 'INVERT THE NUMBER

>NUM_NEGSKIP
SUBR 0 3 = % 'CONVERT BACK TO NUMBER
SUBR 3 1 3 % 'CREATE NUM UNCONVERTED
SWAP 3 4
SRE _34 _012345 'RETURN NUM+UNCONVERTED

>NUM_VALID
DEC 11 'RECOVER NUMBER
ADDR .11 4 = % 'ADD TO NUMBER SO FAR
JNR 3 5 <NUM_HYSKIP
JUMP <NUM_END

'DICTIONARY WORDS

'FIND A CODE POINTER BASED ON LOC+LEN

$FIND
&H0004
<NUMBER

>FIND 'FI
PR _012345 _01
'ONLY USED TO RUN COMPARISON
'R0=LOCATION
'R1=LENGTH

LOADM <_LATEST 2 'R2=CURRENT POINTER
'MOVE 0 3 'R3=TEMP LOCATION
'MOVE 0 4 'R4=TEMP LENGTH

>FI_LOOP
'R2 -> CODE
'MEMORY LAYOUT:

'NAME
'LEN
'LINK
'CODE <--R2

'CHECK FOR END OF LINKED LIST
JEI 0 2 <FI_ERR 'POINT AT LINK (FOR LATER!)

'FIND LENGTH
COPY {2 (4 'R2=[LINK] R4=POINTER TO LENGTH
'DEREFERENCE POINTER
ANDI &H01FF ,4 4 'MASK OUT IMMEDIATE FLAG
JNR 1 4 <FI_NEXT 'LENGTHS DON'T MATCH?

';:;:;:
'LOCATION IS R2-LEN-1
COPY 2 (3 'R3=POINTER TO LENGTH
'LOADR 3 .11
ANDI &H00FF ,3 5 'DEREF R3 LIMIT TO LENGTH 
SUBR 5 3 = % 'SUBTRACT LEN FROM R3
JNR ,0 ,3 <FI_NEXT 'SKIP IF FIRST CHAR EQUAL
FUNC _034 ;@STRCHECK 'CHECK REST OF STRINGS FOR EQUALITY

JER 4 .11 <FI_YES 'SUCCESS?

>FI_NEXT
LOADR 2 = 'FOLLOW LINK TO NEXT WORD
JUMP <FI_LOOP

>FI_ERR
SRE _2 _012345

>FI_YES
'R2 CURRENTLY POINTS TO LINK, FIX THAT
ADDI 1 2 .11 % 'AND PUT ON STACK
'R }2
EXIT _012345

'DICTIONARY HEADER ADDRESS
'UNIQUE TO AVC3FORTH, FOLLOWS LENGTH BACK TO POINT AT START OF ENTRY'S NAME

$>DHA
&H0004
<FIND

>>DHA
'MEMORY LAYOUT:

'NAME
'LEN
'LINK
'CODE <--S11

SUBI 2 .11 = % 'POINT AT LEN
LOADR ,11 .11 'GET LENGTH
ANDI &HFF .11 = 'AND WITH FF
SUBR .11 = = % 'SUB LENGTH
]

'CREATE

'ADDS A WORD HEADER TO THE DICTIONARY

'(LOCATION LENGTH --)

$CREATE
&H0006
<>DHA

>CREATE
PR _0123 _01
'R0=LOCATION
'R1=LENGTH
LOADM <_HERE 2 'R2=HERE
FUNC _012 ;@FCP 'RUN A FORWARDS COPY TO MAKE THE NAME
ADDR 1 2 3 % 'R3=POINTER TO WHERE LENGTH NEEDS TO GO
STORER 1 )3 'STORE AWAY LENGTH
'INC 3
STORER <_LATEST )3 'STORE NEW LINK POINTER
STOREM 3 <_LATEST 'SET LATEST
STOREM 3 <_HERE 'SET HERE
EXIT _0123

'COMMA

$,
&H0001
<CREATE

'POP A CODE WORD, COMPILE IT
>,
STORER .11 <_HERE
INC <_HERE
]

'SWITCH TO IMMEDIATE MODE
$[
&H0201 'IMMEDIATE FLAG SET
<,

>[
STOREIM 0 <_STATE
]

'SWITCH TO COMPILE MODE
$]
&H0001
<[

>]
STOREIM 1 <_STATE
]

'SET LATEST TO IMMEDIATE
$IMMEDIATE
&H0209
<]

>IMMEDIATE
'GET LENGTH WORD
LOADM <_LATEST .11 'GET LATEST
SUBI 2 .11 = % 'SUB 2 TO GET LENGTH POINTER
LOADR ,11 .11 'GET LENGTH
XORI &H0200 .11 = 'FLIP BIT
STORER .11 = 'STORE BACK
]

'SET WORD TO HIDDEN
'EXPECTS CODEWORD POINTER
$HIDDEN
&H0006
<IMMEDIATE

>HIDDEN
SUBI 2 .11 = % 'SUB 2 TO GET LENGTH POINTER
LOADR ,11 .11 'GET LENGTH
XORI &H0100 .11 = 'FLIP BIT
STORER .11 = 'STORE BACK
]

'COLON
$:
&H0001
<HIDDEN

>:
<WORD
<CREATE
R <_LATEST
<HIDDEN
JUMP <]

'SEMICOLON
$;
&H0201
<:

>; ';
I <INTERRUPT
<,
I ] 'PUSH EXIT
<, 'COMPILE EXIT
R <_LATEST
<HIDDEN 'UNHIDE
JUMP <[

'HIDE WORD
$HIDE
&H0004
<;

>HIDE
<WORD
<FIND
JUMP <HIDDEN

'TICK
$'
&H0201
<HIDE

>TICK 'RATHER NOT DEAL WITH POTENTIAL BUGS HERE CAUSED BY USING AN APOSTROPHE AS A LABEL NAME

'IMMEDIATE VERSION OF TICK
<WORD 'GET THE NEXT WORD
<FIND 'FIND ITS CODEWORD POINTER

JNI 0 <_STATE <TICK_STATE 'STATE?
]

>TICK_STATE
I <LIT_TICK
<, 'COMPILE LIT
JUMP <, 'COMPILE VALUE

$LIT_TICK
&H0008
<TICK

>LIT_TICK
JUMP <LIT

'BRANCH UNCONDITIONALLY
$BRANCH
&H0006
<LIT_TICK

>BRANCH
'MODIFY RETURN ADDRESS TO JUMP
LOADR ,12 .11 'GET OFFSET
ADDR .11 .12 = % 'ADD OFFSET
]

'BRANCH CONDITIONALLY
$0BRANCH
&H0007
<BRANCH

>0BRANCH
JEI 0 .11 <BRANCH 'BRANCH IF ZERO
INC .12 'OTHERWISE JUMP OVER OFFSET
]

'LITERAL STRING
$LITSTRING
&H0009
<0BRANCH

>LITSTRING
LOADR ,12 .11 'GET STRING LENGTH
INC .12
R ,12 'GET STRING LOCATION
SWAP .11 = 'SWAP TO GET LOC BEFORE LEN
ADDR ,11 .12 = % 'SKIP PAST STRING
]

'PRINT A STRING
$TELL
&H0004
<LITSTRING

>TELL
STOREIM ! ;_CRPC
STOREIM 1 <_PRINTED
JUMP ;@MCPRINT

'"QUIET" PRINT A STRING
$QTELL
&H0005
<TELL

>QTELL
JUMP ;@MPRINT

'GET A LITERAL CHARACTER
$CHAR
&H0004
<QTELL

>CHAR
<WORD
INC 11 'DROP LENGTH
LOADR .11 = 'GET CHARACTER
]

'EXECUTE A CODE POINTER
$EXECUTE
&H0007
<CHAR

>EXECUTE
G 15 'GET INTO IP

'QUIT AND INTERPRET!!
$INTERPRET
&H0009
<EXECUTE

>INTERPRET
STOREIM 0 <_ISLIT
<WORD
PR _01234 _01
'R0=LOCATION
'R1=LENGTH
FUNC _01 <FIND 'TRY TO FIND WORD
G 2 'R2=CODE POINTER
JEI 0 2 <I_NUMBER 'ASSUME NUMBER IF NOT FOUND

'IN THE DICTIONARY, IS IT IMMEDIATE?
SUBI 2 2 3 % 'GET FLAG POINTER
ANDI &H0200 ,3 3 'GET IMMEDIATE FLAG
JNI 0 3 <I_RUN
JUMP <I_IMMEDIATE


>I_NUMBER
'ASSUME LITERAL NUMBER
STOREIM 1 <_ISLIT 'SET ISLIT
FUNC _01 <NUMBER 'PARSE NUMBER
JNI 0 .11 <I_NERR 'NUM ERROR

MOVE I 2 'WORD IS LIT

>I_IMMEDIATE
'COMPILING OR EXECUTING?
JEI 0 <_STATE <I_RUN 'RUN IF STATE 0

'COMPILING
FUNC _2 <, 'CALL COMMA TO COMPILE
JEI 0 <_ISLIT <I_ERET 'EARLY RETURN IF NOT INT
'COMPILE LITERAL
<,

>I_ERET
EXIT _01234

>I_RUN
JEI 1 <_ISLIT <I_ERET 'LITERAL?

'EXECUTE CODE WORD IN R2
'R 2 'PLACE R2 ON STACK
STOREM 2 <I_CALL
RE _01234 'RECOVER REGISTERS

>I_CALL 0 'SELF-MODIFIED CALL OR RETURN (WHY THE REGISTERS ARE RECOVERED BEFORE THIS POINT)

] 'RETURN

>I_NERR 'ERROR
INC 11 'DROP
I <ERRORMSG
;@BLOCK
;@MCPRINT

'PRINT LAST 64 CHARACTERS OF INPUT BUFFER AS CONTEXT
SUBI 64 <CURRKEY .11 % 'LOCATION
I 64 'LENGTH
;@MCPRINT


EXIT _01234


>ERRORMSG
$ERROR
10
0


'MAIN LOOP OF INTERPRETER. THIS IS WHERE THE MAGIC HAPPENS
$QUIT
&H0004
<INTERPRET

>QUIT
MOVE 0 12 'RESET R12

>QUIT_LOOP
<INTERPRET
JUMP <QUIT_LOOP

'DIVIDE
$/
&H0001
<QUIT

>/
</MOD
SWAP .11 =
INC 11
]

'MOD
$MOD
&H0003
</

>MOD
</MOD
INC 11
]

'SOME CHARACTER CONSTANTS

'NEWLINE
$NL
&H0002
<MOD

>NL
I 10
]

'BLANK
$BL
&H0002
<NL

>BL
I 32
]

'PRINT CR
$CR
&H0002
<BL

>CR
<NL
JUMP <EMIT

'PRINT SPACE
$SPACE
&H0005
<CR

'AWKWARD LABEL TO AVOID NAME CLASH
>-SPACE
<BL
JUMP <EMIT

'BACKSPACE
$BS
&H0002
<-SPACE

>BS
I 8
JUMP <EMIT


'NEGATE NUMBER
$NEGATE
&H0006
<BS

>NEGATE
TWO .11 =
]

'TRUE
$TRUE
&H0004
<NEGATE

>-TRUE
JUMP <TRUE

'FALSE
$FALSE
&H0005
<-TRUE

>-FALSE
JUMP <FALSE

'NOT
$NOT
&H0003
<-FALSE

>NOT
JUMP <0=

'LITERAL
$LITERAL
&H0207
<NOT

>LITERAL
I I
<, 'COMPILE LIT
JUMP <, 'COMPILE LITERAL ITSELF

'CHARACTER CONSTANTS
$':'
&H0003
<LITERAL

>COLON
I !:
]

$';'
&H0003
<COLON

>SEMICOLON
I !;
]

$'('
&H0003
<SEMICOLON

>LEFTB
I !(
]

$')'
&H0003
<LEFTB

>RIGHTB
I !)
]

$'"'
&H0003
<RIGHTB

>QUOTE
I !"
]

$'A'
&H0003
<QUOTE

>A
I !A
]

$'0'
&H0003
<A

>0
I !0
]

$'-'
&H0003
<0

>HYPHEN
I !-
]

$'.'
&H0003
<HYPHEN

>DOT
I !.
]

'COMPILE EVEN IF IMMEDIATE WORD!
$[COMPILE]
&H0209
<DOT

>[COMPILE]
<WORD
<FIND
JUMP <,

'FLOW CONTROL
$RECURSE
&H0207
<[COMPILE]

>RECURSE
R <_LATEST 'GET LATEST POINTER
JUMP <, 'COMPILE IT

'IF
$IF
&H0202
<RECURSE

>IF
I <0BRANCH
<, 'COMPILE 0B
R <_HERE 'SAVE CURRENT OFFSET
I 0
JUMP <, 'COMPILE A ZERO


'THEN
$THEN
&H0204
<IF

>THEN
COPY ,11 .11
R <_HERE 'GET HERE
SWAP .11 = 'SWAP
SUBR .11 = = % 'CALCULATE OFFSET
SWAP .11 = 'SWAP
JUMP <! 'STORE IN IF BRANCH

'ELSE
$ELSE
&H0204
<THEN

>ELSE
I <BRANCH
<, 'DEFINITE BRANCH
R <_HERE 'GET HERE
I 0
<, 'COMPILE OFFSET
SWAP .11 = 'BACKFILL
COPY ,11 .11
R <_HERE
SWAP .11 =
SUBR .11 = = %
SWAP .11 =
JUMP <!

'BEGIN
$BEGIN
&H0205
<ELSE

>BEGIN
R <_HERE
]

'UNTIL
$UNTIL
&H0205
<BEGIN

>UNTIL
I <INTERRUPT
<,
I <0BRANCH
<, 'COMPILE 0B
R <_HERE
SUBR .11 = = % 'CALCULATE OFFSET BACK
JUMP <, 'COMPILE OFFSET

'AGAIN
$AGAIN
&H0205
<UNTIL

>AGAIN
I <INTERRUPT
<,
I <BRANCH
<, 'COMPILE A BRANCH
R <_HERE
SUBR .11 = = %
JUMP <, 'COMPILE THE OFFSET

'WHILE
$WHILE
&H0205
<AGAIN

>WHILE
I <0BRANCH
<, 'COMPILE A 0BRANCH
R <_HERE
I 0
JUMP <, 'COMPILE DUMMY OFFSET

'REPEAT
$REPEAT
&H0206
<WHILE

>REPEAT
I <INTERRUPT
<,
I <BRANCH
<, 'COMPILE A BRANCH
SWAP .11 =
R <_HERE
SUBR .11 = = %
<, 'GET OFFSET
COPY ,11 .11
R <_HERE
SWAP .11 =
SUBR .11 = = %
SWAP .11 =
JUMP <!

'UNLESS
$UNLESS
&H0206
<REPEAT

>UNLESS
I <NOT
<, 'COMPILE NOT
JUMP <IF

'NIP
$NIP
&H0003
<UNLESS

>NIP
SWAP .11 =
INC 11
]

'OVER
$OVER
&H0004
<NIP

>OVER
COPY ?1 .11
]

'TUCK
$TUCK
&H0004
<OVER

>TUCK
SWAP .11 =
COPY ?1 .11
]

'PICK
$PICK
&H0004
<TUCK

>PICK
INC .11
<DSP@
ADDR .11 = = %
JUMP <@

'DECIMAL
$DECIMAL
&H0007
<PICK

>DECIMAL
STOREIM 10 ;_BASE
]

'HEX
$HEX
&H0003
<DECIMAL

>HEX
STOREIM 16 ;_BASE
]

'CONSTANT
$CONSTANT
&H0008
<HEX

>CONSTANT
<WORD
<CREATE
I I
<, 'APPEND LIT
<, 'APPEND VALUE
I ]
JUMP <, 'APPEND EXIT

'ALLOT
$ALLOT
&H0005
<CONSTANT

>ALLOT
R <_HERE
SWAP .11 =
ADDR .11 <_HERE = %
]

'VARIABLE
$VARIABLE
&H0008
<ALLOT

>VARIABLE
I 1
<ALLOT 'ALLOT 1 WORD
<WORD
<CREATE
I I
<, 'APPEND LIT
<, 'APPEND POINTER
I ]
JUMP <, 'APPEND EXIT

'VALUE
$VALUE
&H0005
<VARIABLE

>VALUE
<WORD
<CREATE
I I
<, 'APPEND LIT
<, 'APPEND VALUE
I ]
JUMP <, 'APPEND EXIT

'?HIDDEN
$?HIDDEN
&H0007
<VALUE

>?HIDDEN
'GET LENGTH FLAG
DEC .11
DEC .11
LOADR .11 = 'DEREF
ANDI &H0100 .11 = 'AND RESULT
]

'?IMMEDIATE
$?IMMEDIATE
&H000A
<?HIDDEN

>?IMMEDIATE
'GET LENGTH FLAG
DEC .11
DEC .11
LOADR .11 = 'DEREF
ANDI &H0200 .11 = 'AND RESULT
]

'I FORGOR
$FORGET
&H0006
<?IMMEDIATE

>FORGET 'NEEDS REWORKING FOR MY MEMORY SCHEME
<WORD
<FIND
'GET EXECUTION ADDRESS
'LATEST NEEDS TO BECOME LAST POINTER
SUBI 1 .11 .11 % 'POINTER TO LINK
LOADR ,11 .11 'DEREF LINK
STOREM .11 <_LATEST 'SET LATEST

SUBI 1 .11 = % 'POINTER TO LENGTH
LOADR ,11 .11 'DEREF LENGTH
ANDI &H00FF .11 = 'RESTRICT LENGTH
SUBR .11 = <_HERE % 'SET NEW HERE
]

'CASE
$CASE
&H0204
<FORGET

>CASE
I 0 'PUSH 0 TO MARK BOTTOM OF STACK
]

'OF
$OF
&H0202
<CASE

>OF
I <OVER
<,
I <=
<,
<IF
I <DROP
<,
]

'ENDOF
$ENDOF
&H0205
<OF

>ENDOF
JUMP <ELSE

'NONAME
$:NONAME
&H0007
<ENDOF

>:NONAME
I 0
I 0
<CREATE
R <_HERE
JUMP <]

'[']
$[']
&H0203
<:NONAME

>[TICK]
I I
JUMP <, 'JUST COMPILE LIT

'EXCEPTION-MARKER
$EXCEPTION-MARKER
&H0010
<[TICK]

>EXCEPTION-MARKER
<RDROP
I 0
]

$CATCH
&H0005
<EXCEPTION-MARKER

>CATCH
<DSP@
<1+
<>R
I <EXCEPTION-MARKER
<1+
<>R
JUMP <EXECUTE

$BYE
&H0003
<CATCH

>BYE
HALT

'AVC3FORTH-SPECIFICS

'ENABLE ACCESS TO
' REFRESH
' CLS
' PIXEL LIBRARY
' MS/TIME/DATE (DELAY INSTRUCTION?)
' RANDOM NUMBERS
' LOADING
' TOUCH AND BUTTONS
' BLOCK OPERATIONS
' SPRITES
' 64BIT LIBRARY

'RELEVANT SYSTEM VARIABLES FOR EACH

$REFR
&H0004
<BYE

>REFR
REFR
]

'( X Y -- )

'TURN ON A PIXEL
$PLOT
&H0004
<REFR

>PLOT
JUMP ;@@PXON

'TURN OFF A PIXEL
$UNPLOT
&H0006
<PLOT

>UNPLOT
JUMP ;@@PXOFF

'FLIP A PIXEL
$FLIP
&H0004
<UNPLOT

>FLIP
JUMP ;@@PXFLIP

' ( X Y -- RESULT)

'TEST A PIXEL
$TEST
&H0004
<FLIP

>TEST
JUMP ;@@PXTEST

'TEST AND FLIP
$TESTFLIP
&H0008
<TEST

>TESTFLIP
JUMP ;@PXTF

' ( X Y -- X Y )

'WRAP PIXEL VALUES
$PXWRAP
&H0006
<TESTFLIP

>PXWRAP
JUMP ;@PXWRAP

'CLIP PIXEL VALUES
$PXCLIP
&H0006
<PXWRAP

>PXCLIP
JUMP ;@PXCLIP

'( -- X Y T )

'GET TOUCH IN PIXEL UNITS
$TOUCHPIX
&H0008
<PXCLIP

>TOUCHPIX
JUMP ;@TOUCHPIX

'( X Y M -- )
'USE MODE TO TURN PIXEL ON OR OFF
$PXMODE
&H0006
<TOUCHPIX

>PXMODE
JUMP ;@PXMODE

'INPUT

' ( -- N )

$BUTTON
&H0006
<PXMODE

>BUTTON
BUTTON .11
]

$RND
&H0003
<BUTTON

>RND
JUMP ;@RND


' ( -- X Y T )

$TOUCH
&H0005
<RND

>TOUCH
JUMP ;@TOUCH

' ( X Y T -- CX CY T )
$TCHAR
&H0005
<TOUCH

>TCHAR
JUMP ;@TCHAR

' ( CX CY T -- ADDRESS BEZEL-FLAG TIME

$TADDRESS
&H0008
<TCHAR

>TADDRESS
JUMP ;@TADDRESS

' ( BEZEL? T -- VALID? )

$TVALID
&H0006
<TADDRESS

>TVALID
JUMP ;@TVALID

' ( -- ADDRESS, VALID? )

$VALIDTOUCH
&H000A
<TVALID

>VALIDTOUCH
JUMP ;@@TOUCH

'TERMINAL
$CLS
&H0003
<VALIDTOUCH

>CLS
JUMP ;@CLS

'( -- N N )
$MIL
&H0003
<CLS

>MIL
MIL .11 = 'PUT BOTH MILLISECS ON STACK
]

'MORE "FORTHY" 16-BIT VERSION OF MILLISEC

$MS
&H0002
<MIL

>MS
<MIL
JUMP <NIP

'( -- H M S )

$TIME
&H0004
<MS

>TIME
TIME .11 = =
]

'( -- Y M D )

$DATE
&H0004
<TIME

>DATE
DATE .11 = =
]

'( MS -- )
$DELAY
&H0005
<DATE

>DELAY
PR _01 _0
'R0=DELAY AMOUNT
MIL 1 = 'GET START TIME
ADDR 0 1 = % 'GET END TIME

>DELAY_LOOP
MIL 0 = 'GET CURRENT TIME
JLR- 0 1 <DELAY_LOOP

EXIT _01

'RAMTOP
$RAMTOP
&H0006
<DELAY

>RAMTOP
I <_RAMTOP
]

' ( -- N )

'SET UPPER DISPLAY POINTER
$UDP!
&H0004
<RAMTOP

>UDP!
G 13
]

'SET LOWER DISPLAY POINTER
$LDP!
&H0004
<UDP!

>LDP!
G 14
]

'GET UPPER DISPLAY POINTER
$UDP@
&H0004
<LDP!

>UDP@
R 13
]

'GET LOWER DISPLAY POINTER
$LDP@
&H0004
<UDP@

>LDP@
R 14
]

'LOAD CODE
'THIS MUST BE AT THE END OF A PROGRAM OR INPUT BECAUSE IT RESETS THE INPUT BUFFER

' ( -- )

$LOAD
&H0004
<LDP@

>LOAD
LOADM <_HERE 14
I <LOADNAME
I 14
;@ERASE 'ERASE LOAD BUFFER

<WORD
I <LOADNAME 'LOC, LEN, LDBUFFER_LOCATION
SWAP .11 =
<CMOVE 'COPY TO NAME BUFFER

'ERASE INPUT BUFFER
I <COMMAND
I &H2000
;@ERASE

PE _012
MOVE <LOADNAME 0 'NAME LOCATION
MOVE <COMMAND 1 'INPUT BUFFER LOCATION
LOAD 0 1 <BUFFTOP % 'LOAD
MOVE <COMMAND <CURRKEY
EXIT _012

'LOAD TEXT INTO MEMORY
'( LOCATION -- END )
$TEXTLOAD
&H0008
<LOAD

>TEXTLOAD
I <LOADNAME
I 14
;@ERASE 'ERASE LOAD BUFFER

<WORD
I <LOADNAME 'LOC, LEN, LDBUFFER_LOCATION
SWAP .11 =
<CMOVE 'COPY TO NAME BUFFER

PE _012
MOVE <LOADNAME 0 'NAME LOCATION
LOAD 0 .11 .11 % 'LOAD
MOVE <COMMAND <CURRKEY
EXIT _012

'INTERRUPT IF ZL+ZR
$INTERRUPT
&H0009
<TEXTLOAD

>INTERRUPT
BUTTON .11
JEI 6144 .11 <QUIT
]

'RESET STACK
$RESET
&H0005
<INTERRUPT

>RESET
MOVE &HF000 11
]

'OUTPUT CURRENT STACK DEPTH

$DEPTH
&H0005
<RESET

>DEPTH
<S0
<DSP@
<-
JUMP <1-

'QUEUE WORDS

'ADD ITEM FORWARDS
$FEQ
&H0003
<DEPTH

>FEQ
JUMP ;@FEQ

'TAKE ITEM FORWARDS
$FDQ
&H0003
<FEQ

>FDQ
JUMP ;@FDQ

'ADD ITEM BACKWARDS
$BEQ
&H0003
<FDQ

>BEQ
JUMP ;@BEQ

'TAKE ITEM FORWARDS
$BDQ
&H0003
<BEQ

>BDQ
JUMP ;@BDQ

'CLEAR QUEUE
$CQ
&H0002
<BDQ

>CQ
JUMP ;@CLRQUEUE

'MILLISECOND LOOP
'KEEPS LOOPING UNTIL THE TIME IS UP

'PUSH TIME, THEN
'MSLOOP-MSREP

$MSLOOP
&H0206
<CQ

>MSLOOP
I <MS <, 'GET CURRENT MILLISEC
I <+ <, 'ADD TO GET END TIME
<BEGIN 'COMPILE BEGIN
I <DUP <, 'END TIME
I <MS <, 'MS
I <- <, 'END-CURRENT
I <0> <, 'POSITIVE?
JUMP <WHILE 'COMPILE WHILE

'DROP AFTER REPEAT
$MSREP
&H0205
<MSLOOP

>MSREP
<REPEAT
I <DROP
JUMP <,

$MSBEGIN
&H0207
<MSREP

>MSBEGIN
I <MS <, 'GET CURRENT MILLISEC
I <+ <, 'ADD TO GET END TIME
JUMP <BEGIN 'COMPILE BEGIN

$MSUNTIL
&H0207
<MSBEGIN

>MSUNTIL
I <DUP <, 'END TIME
I <MS <, 'MS
I <- <, 'END-CURRENT
I <0<= <, 'NEGATIVE?
<UNTIL
I <DROP
JUMP <,


'BUTTON SYMBOLS

$UP
&H0002
<MSUNTIL

>UP
I #UP
]

$RIGHT
&H0005
<UP

>RIGHT
I #RIGHT
]

$DOWN
&H0004
<RIGHT

>DOWN
I #DOWN
]

$LEFT
&H0004
<DOWN

>LEFT
I #LEFT
]

$TEXIT
&H0205
<LEFT

>TEXIT
I I
<, 'COMPILE PUSH
I 0
<, 'COMPILE 0
I <<>
<, 'COMPILE <>
<IF
I ] 'COMPILE EXIT
<,
JUMP <THEN

$FEXIT
&H0205
<TEXIT

>FEXIT
I I
<, 'COMPILE PUSH
I 0
<, 'COMPILE 0
I <=
<, 'COMPILE =
<IF
I ] 'COMPILE EXIT
<,
JUMP <THEN

'DRAW A SPRITE
' ( LOCATION ADDRESS -- )
$DRAW
&H0004
<FEXIT

>DRAW
JUMP ;@DRAW

'UNDRAW A SPRITE
' ( LOCATION ADDRESS -- )
$CLEAR
&H0005
<DRAW

>LAT
>CLEAR
JUMP ;@CLEAR

>DEND 'DICTIONARY END

